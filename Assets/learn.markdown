# 学习日志
## 游戏角色的创建
### 导入角色
1.在资源商店中选中角色后， 点击‘在$unity$中打开’；
2.
3.

### 创建动作

<br/>

## 地图的创建


<br/>

## 如何控制游戏角色移动
### 添加插件
1. 为 $player$ 添加插件，输入 $player\ input$
2. 个人理解的 $player\ input$ 的工作模式
    * $Input\ Action\ Asset$用来创建动作， 同时也可以绑定物理按键， 创建完后就会在$player\ input$的“事件”中出现响应的动作事件；
    * `Invoke Unity Events`指定， 当事件触发时， $unity$需要调用脚本函数：
    * “事件”中可以为某个动作添加函数， 可以选择是运行程序的时候按下按键触发动作， 还是$unity$打开的时候只要按了按键就触发动作， 显然是前者；
    * 动作可以绑定脚本中的函数， 比如`public void Move(InputAction.CallbackContext context)`, 需要注意的是函数中传入的参数表示的是输入的详细信息， 我的理解是将输入的信息打包一起传进来了；
    * 脚本需要拖动到$player\ input$中， 这样才可以为事件添加对应的函数；
  
### 脚本的编写
1. 要能在函数中传入封装好的输入的信息， 需要引用`using UnityEngine.InputSystem;` 个人感觉类似`c++`中的头文件。
2. 一些函数的理解
    * `Move`函数： `InputX = context.ReadValue<Vector2>().x;`, 实时获取玩家“水平输入的方向和强度”的数值， 比如`InputX`, 取值范围$[-1, 1]$, 为正时说明是正方向， 乘上基础速度， 就得到了一个像$x$轴正方向的速度；
    * `Update`函数： 更新角色的物理位置， 给了一个正方向的速度后，物理引擎`rig`就会给它一个向右的力， 保持匀速向右运动， 更有意思的是`rig`可以检测碰撞, `rig.velocity = new Vector2(MoveSpeed * InputX, rig.velocity.y);` 纵方向的速度没变， 就不会上下移动。
    * 思考一下， 整个过程与按键的绑定有关， 向右移动绑定`W`, 抽象理解， 像是`W`绑定了`Input`的$[0, 1]$, 按下`W`, 就给它赋了一个正值, `A`类似。
    * 是速度控制移动， 如果是距离， 比如直接更新角色的横坐标， 应该会产生瞬移的效果？

### 动画切换
1. 将run动画拖入动画控制器， 与idle动画连线, 用来创建过渡， 这样就可以让idle转换到run
2. 需要在动画器中创建参数， 这样就可以有依据来判断是不是要转换动作
3. 点击idle 到 run 的那根过渡线， 就可以打开动作转换的检查器
4. $conditions$是条件的意思， 说的是动画切换的条件， 添加之间设计好的参数， 设为true, 意思是isRun为真就从待机切换到跑步
5. isRun是否为真， 可以在代码中使用InputX来检测， 
6. 可以取消检查器中的退出时间， 个人理解是， 动作切换后， 延迟多少时间在退出当前动作， 然后切换其他动作


### 判断是否与地面接触
1. 虽然我们将地面与角色做了碰撞检测， 但是这还不够， 很多时候都需要显示的知道到底有没有发生碰撞
2. 可以给角色添加一个空物件，把这个空物件拖到的角色的脚的位置， 然后用这个物件的位置和地板检测角色有没有站在地板上
3. 需要给场景添加一个图层， 专门用来检测

